<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网络函数的零点与极点动画演示</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e7f1 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-weight: 600;
            font-size: 2.2rem;
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .canvas-wrapper {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        canvas {
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            display: block;
            background: rgba(250, 250, 250, 0.5);
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        
        button {
            background: rgba(74, 144, 226, 0.85);
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.2);
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background: rgba(53, 122, 189, 0.9);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(53, 122, 189, 0.25);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .info-panel {
            background: rgba(232, 244, 253, 0.7);
            border-left: 4px solid rgba(74, 144, 226, 0.7);
            padding: 20px;
            margin-top: 25px;
            border-radius: 10px;
            color: #2c3e50;
            line-height: 1.7;
        }
        
        .info-panel h3 {
            margin-top: 0;
            color: #2c3e50;
            font-weight: 600;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 10px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 15px;
            font-weight: 500;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-symbol {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .function-display {
            background: rgba(240, 240, 240, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            margin: 15px 0 25px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #2c3e50;
            border: 1px solid rgba(0, 0, 0, 0.08);
            font-weight: 600;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.03);
        }
        
        .explanation {
            background: rgba(255, 243, 205, 0.7);
            border: 1px solid rgba(255, 234, 167, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
            color: #856404;
            line-height: 1.7;
        }
        
        .explanation strong {
            color: #7d5a00;
        }
        
        .explanation h3 {
            margin-top: 0;
            color: #856404;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>网络函数的零点与极点动画演示</h1>
        
        <div class="function-display" id="functionDisplay">
            H(s) = 1 / (s + 2)
        </div>
        
        <div class="main-content">
            <div class="canvas-wrapper">
                <canvas id="poleZeroCanvas" width="400" height="400"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <svg width="20" height="20">
                                <circle cx="10" cy="10" r="8" fill="none" stroke="#FF6B6B" stroke-width="2"/>
                            </svg>
                        </div>
                        <span>零点</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <svg width="20" height="20">
                                <path d="M 4 4 L 16 16 M 16 4 L 4 16" stroke="#4A90E2" stroke-width="2"/>
                            </svg>
                        </div>
                        <span>极点</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-wrapper">
                <canvas id="frequencyCanvas" width="400" height="400"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <svg width="20" height="20">
                                <line x1="0" y1="10" x2="20" y2="10" stroke="#FF6B6B" stroke-width="2"/>
                            </svg>
                        </div>
                        <span>幅频响应</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <line x1="0" y1="10" x2="20" y2="10" stroke="#4ECDC4" stroke-width="2"/>
                        </div>
                        <span>相频响应</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="setSystem(1)">系统1：低通滤波</button>
            <button onclick="setSystem(2)">系统2：高通滤波</button>
            <button onclick="setSystem(3)">系统3：带通滤波</button>
            <button onclick="setSystem(4)">系统4：自定义</button>
            <button onclick="toggleAnimation()">启动/停止动画</button>
        </div>
        
        <div class="info-panel">
            <h3>当前系统特性</h3>
            <p id="systemInfo">
                <strong>系统类型：</strong>低通滤波<br>
                <strong>零点：</strong>无<br>
                <strong>极点：</strong>s = -2<br>
                <strong>说明：</strong>单极点系统，具有低通特性。-3dB截止频率约2 rad/s
            </p>
        </div>
        
        <div class="explanation">
            <h3>概念说明</h3>
            <p><strong>零点：</strong>使网络函数H(s)=0的s值，在复平面上用○表示。零点吸引频率响应曲线向零衰减。</p>
            <p><strong>极点：</strong>使网络函数H(s)→∞的s值，在复平面上用×表示。极点使频率响应产生峰值。</p>
            <p><strong>应用：</strong>通过合理配置零极点位置，可以设计出低通、高通、带通等各种滤波器。</p>
        </div>
    </div>

    <script>
        // 全局变量
        let poles = [{re: -2, im: 0}];
        let zeros = [];
        let animationId = null;
        let isAnimating = false;
        let frequency = 0;
        
        // 获取画布
        const poleZeroCanvas = document.getElementById('poleZeroCanvas');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const pzCtx = poleZeroCanvas.getContext('2d');
        const freqCtx = frequencyCanvas.getContext('2d');
        
        // 坐标转换函数
        function toCanvasCoords(canvas, re, im) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 30; // 30像素/单位
            return {
                x: centerX + re * scale,
                y: centerY - im * scale
            };
        }
        
        function fromCanvasCoords(canvas, x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 30;
            return {
                re: (x - centerX) / scale,
                im: (centerY - y) / scale
            };
        }
        
        // 绘制复平面
        function drawComplexPlane(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 清空画布
            ctx.fillStyle = 'rgba(250, 250, 250, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;
            const gridSize = 30;
            
            for (let i = 0; i < canvas.width; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i < canvas.height; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // 绘制虚轴
            ctx.strokeStyle = 'rgba(44, 62, 80, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // 绘制实轴
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // 绘制刻度
            ctx.fillStyle = '#2c3e50';
            ctx.font = '13px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // 实轴刻度（-5到5）
            for (let i = -5; i <= 5; i++) {
                if (i !== 0) {
                    const x = centerX + i * gridSize;
                    ctx.fillText(i, x, centerY + 8);
                }
            }
            
            // 虚轴刻度
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = -5; i <= 5; i++) {
                if (i !== 0) {
                    const y = centerY - i * gridSize;
                    ctx.fillText(i + 'j', centerX - 8, y);
                }
            }
            
            // 标记原点
            ctx.fillStyle = '#2c3e50';
            ctx.fillText('0', centerX - 12, centerY + 8);
        }
        
        // 计算频率响应
        function calculateFrequencyResponse(omega) {
            let magnitude = 1;
            let phase = 0;
            
            const s = {re: 0, im: omega};
            
            // 零点贡献
            zeros.forEach(zero => {
                const distance = Math.sqrt(
                    Math.pow(s.re - zero.re, 2) + 
                    Math.pow(s.im - zero.im, 2)
                );
                magnitude *= distance;
                
                const angle = Math.atan2(s.im - zero.im, s.re - zero.re);
                phase += angle;
            });
            
            // 极点贡献
            poles.forEach(pole => {
                const distance = Math.sqrt(
                    Math.pow(s.re - pole.re, 2) + 
                    Math.pow(s.im - pole.im, 2)
                );
                magnitude /= distance;
                
                const angle = Math.atan2(s.im - pole.im, s.re - pole.re);
                phase -= angle;
            });
            
            return {magnitude, phase};
        }
        
        // 绘制极点和零点
        function drawPolesAndZeros() {
            drawComplexPlane(pzCtx, poleZeroCanvas);
            
            // 绘制极点 (×)
            poles.forEach(pole => {
                const coords = toCanvasCoords(poleZeroCanvas, pole.re, pole.im);
                
                // 添加发光效果
                pzCtx.shadowColor = 'rgba(74, 144, 226, 0.5)';
                pzCtx.shadowBlur = 15;
                
                pzCtx.strokeStyle = '#4A90E2';
                pzCtx.lineWidth = 3;
                pzCtx.beginPath();
                pzCtx.moveTo(coords.x - 10, coords.y - 10);
                pzCtx.lineTo(coords.x + 10, coords.y + 10);
                pzCtx.moveTo(coords.x + 10, coords.y - 10);
                pzCtx.lineTo(coords.x - 10, coords.y + 10);
                pzCtx.stroke();
                
                // 重置发光
                pzCtx.shadowBlur = 0;
            });
            
            // 绘制零点 (○)
            zeros.forEach(zero => {
                const coords = toCanvasCoords(poleZeroCanvas, zero.re, zero.im);
                
                // 添加发光效果
                pzCtx.shadowColor = 'rgba(255, 107, 107, 0.5)';
                pzCtx.shadowBlur = 15;
                
                pzCtx.strokeStyle = '#FF6B6B';
                pzCtx.lineWidth = 3;
                pzCtx.beginPath();
                pzCtx.arc(coords.x, coords.y, 10, 0, 2 * Math.PI);
                pzCtx.stroke();
                
                // 重置发光
                pzCtx.shadowBlur = 0;
            });
        }
        
        // 绘制频率响应
        function drawFrequencyResponse() {
            // 清空画布
            freqCtx.fillStyle = 'rgba(250, 250, 250, 0.7)';
            freqCtx.fillRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);
            
            const width = frequencyCanvas.width;
            const height = frequencyCanvas.height;
            const padding = 40;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            // 绘制坐标轴
            freqCtx.strokeStyle = 'rgba(44, 62, 80, 0.3)';
            freqCtx.lineWidth = 1;
            
            // X轴
            freqCtx.beginPath();
            freqCtx.moveTo(padding, height - padding);
            freqCtx.lineTo(width - padding, height - padding);
            freqCtx.stroke();
            
            // Y轴
            freqCtx.beginPath();
            freqCtx.moveTo(padding, padding);
            freqCtx.lineTo(padding, height - padding);
            freqCtx.stroke();
            
            // 绘制频率响应曲线
            const maxOmega = 10;
            const magnitudePoints = [];
            const phasePoints = [];
            
            for (let i = 0; i <= plotWidth; i++) {
                const omega = (i / plotWidth) * maxOmega;
                const response = calculateFrequencyResponse(omega);
                
                // 幅频响应 (dB)
                const db = 20 * Math.log10(response.magnitude + 1e-10);
                const magnitudeY = height - padding - ((db + 40) / 80) * plotHeight;
                magnitudePoints.push({x: padding + i, y: magnitudeY});
                
                // 相频响应
                const phaseDeg = response.phase * 180 / Math.PI;
                const phaseY = height - padding - ((phaseDeg + 180) / 360) * plotHeight;
                phasePoints.push({x: padding + i, y: phaseY});
            }
            
            // 绘制幅频响应
            freqCtx.strokeStyle = '#FF6B6B';
            freqCtx.lineWidth = 2;
            freqCtx.beginPath();
            magnitudePoints.forEach((point, i) => {
                if (i === 0) {
                    freqCtx.moveTo(point.x, point.y);
                } else {
                    freqCtx.lineTo(point.x, point.y);
                }
            });
            freqCtx.stroke();
            
            // 绘制相频响应
            freqCtx.strokeStyle = '#4ECDC4';
            freqCtx.lineWidth = 2;
            freqCtx.beginPath();
            phasePoints.forEach((point, i) => {
                if (i === 0) {
                    freqCtx.moveTo(point.x, point.y);
                } else {
                    freqCtx.lineTo(point.x, point.y);
                }
            });
            freqCtx.stroke();
            
            // 绘制图例
            freqCtx.fillStyle = '#2c3e50';
            freqCtx.font = '13px "Segoe UI", sans-serif';
            freqCtx.textAlign = 'left';
            
            // 幅度刻度
            for (let db = -40; db <= 40; db += 20) {
                const y = height - padding - ((db + 40) / 80) * plotHeight;
                freqCtx.fillText(db + 'dB', 5, y);
            }
            
            // 相位刻度
            freqCtx.textAlign = 'right';
            for (let phase = -180; phase <= 180; phase += 90) {
                const y = height - padding - ((phase + 180) / 360) * plotHeight;
                freqCtx.fillText(phase + '°', width - 5, y);
            }
            
            // 频率刻度
            freqCtx.textAlign = 'center';
            freqCtx.fillText('0', padding, height - padding + 20);
            freqCtx.fillText('5', padding + plotWidth / 2, height - padding + 20);
            freqCtx.fillText('10', width - padding, height - padding + 20);
            freqCtx.fillText('ω (rad/s)', width / 2, height - 5);
        }
        
        // 设置系统
        function setSystem(systemType) {
            switch(systemType) {
                case 1: // 低通滤波
                    poles = [{re: -2, im: 0}];
                    zeros = [];
                    updateFunctionDisplay('H(s) = 1 / (s + 2)');
                    updateSystemInfo('低通滤波', '无', 's = -2', '单极点系统，具有低通特性。-3dB截止频率约2 rad/s');
                    break;
                case 2: // 高通滤波
                    poles = [{re: -1, im: 0}];
                    zeros = [{re: 0, im: 0}];
                    updateFunctionDisplay('H(s) = s / (s + 1)');
                    updateSystemInfo('高通滤波', 's = 0', 's = -1', '零点在原点，极点在-1，构成高通滤波器');
                    break;
                case 3: // 带通滤波
                    poles = [
                        {re: -0.5, im: 2},
                        {re: -0.5, im: -2}
                    ];
                    zeros = [{re: 0, im: 0}];
                    updateFunctionDisplay('H(s) = s / [(s + 0.5 - 2j)(s + 0.5 + 2j)]');
                    updateSystemInfo('带通滤波', 's = 0', 's = -0.5 ± 2j', '共轭极点对构成谐振，零点在原点');
                    break;
                case 4: // 自定义
                    poles = [
                        {re: -1, im: 1.5},
                        {re: -1, im: -1.5}
                    ];
                    zeros = [
                        {re: -3, im: 0},
                        {re: 0, im: 0}
                    ];
                    updateFunctionDisplay('H(s) = s(s + 3) / [(s + 1 - 1.5j)(s + 1 + 1.5j)]');
                    updateSystemInfo('自定义系统', 's = 0, s = -3', 's = -1 ± 1.5j', '双零点和共轭极点对，具有复杂频率特性');
                    break;
            }
            drawPolesAndZeros();
            drawFrequencyResponse();
        }
        
        // 更新函数显示
        function updateFunctionDisplay(functionStr) {
            document.getElementById('functionDisplay').textContent = functionStr;
        }
        
        // 更新系统信息
        function updateSystemInfo(type, zerosStr, polesStr, description) {
            document.getElementById('systemInfo').innerHTML = `
                <strong>系统类型：</strong>${type}<br>
                <strong>零点：</strong>${zerosStr}<br>
                <strong>极点：</strong>${polesStr}<br>
                <strong>说明：</strong>${description}
            `;
        }
        
        // 动画控制
        function animate() {
            if (!isAnimating) return;
            
            // 更新频率
            frequency += 0.05;
            if (frequency > 10) frequency = 0;
            
            // 高亮当前频率点
            drawFrequencyResponse();
            
            // 在幅频和相频曲线上标记当前频率点
            const response = calculateFrequencyResponse(frequency);
            const db = 20 * Math.log10(response.magnitude + 1e-10);
            const phaseDeg = response.phase * 180 / Math.PI;
            
            const padding = 40;
            const plotWidth = frequencyCanvas.width - 2 * padding;
            const x = padding + (frequency / 10) * plotWidth;
            
            // 幅频点
            const magnitudeY = frequencyCanvas.height - padding - ((db + 40) / 80) * (frequencyCanvas.height - 2 * padding);
            freqCtx.fillStyle = '#FF6B6B';
            freqCtx.beginPath();
            freqCtx.arc(x, magnitudeY, 4, 0, 2 * Math.PI);
            freqCtx.fill();
            
            // 相频点
            const phaseY = frequencyCanvas.height - padding - ((phaseDeg + 180) / 360) * (frequencyCanvas.height - 2 * padding);
            freqCtx.fillStyle = '#4ECDC4';
            freqCtx.beginPath();
            freqCtx.arc(x, phaseY, 4, 0, 2 * Math.PI);
            freqCtx.fill();
            
            // 添加发光效果
            freqCtx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            freqCtx.shadowBlur = 8;
            freqCtx.fill();
            freqCtx.shadowBlur = 0;
            
            animationId = requestAnimationFrame(animate);
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animate();
            } else {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        // 鼠标交互
        let draggedElement = null;
        let dragOffset = {x: 0, y: 0};
        
        poleZeroCanvas.addEventListener('mousedown', (e) => {
            const rect = poleZeroCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 检查是否点击了极点或零点
            const coords = fromCanvasCoords(poleZeroCanvas, x, y);
            
            // 检查极点
            for (let i = 0; i < poles.length; i++) {
                const pole = poles[i];
                const poleCoords = toCanvasCoords(poleZeroCanvas, pole.re, pole.im);
                const dist = Math.sqrt(Math.pow(x - poleCoords.x, 2) + Math.pow(y - poleCoords.y, 2));
                if (dist < 15) {
                    draggedElement = {type: 'pole', index: i};
                    dragOffset = {x: x - poleCoords.x, y: y - poleCoords.y};
                    return;
                }
            }
            
            // 检查零点
            for (let i = 0; i < zeros.length; i++) {
                const zero = zeros[i];
                const zeroCoords = toCanvasCoords(poleZeroCanvas, zero.re, zero.im);
                const dist = Math.sqrt(Math.pow(x - zeroCoords.x, 2) + Math.pow(y - zeroCoords.y, 2));
                if (dist < 15) {
                    draggedElement = {type: 'zero', index: i};
                    dragOffset = {x: x - zeroCoords.x, y: y - zeroCoords.y};
                    return;
                }
            }
        });
        
        poleZeroCanvas.addEventListener('mousemove', (e) => {
            if (!draggedElement) return;
            
            const rect = poleZeroCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left - dragOffset.x;
            const y = e.clientY - rect.top - dragOffset.y;
            
            const coords = fromCanvasCoords(poleZeroCanvas, x, y);
            
            if (draggedElement.type === 'pole') {
                poles[draggedElement.index] = {re: coords.re, im: coords.im};
            } else {
                zeros[draggedElement.index] = {re: coords.re, im: coords.im};
            }
            
            drawPolesAndZeros();
            drawFrequencyResponse();
        });
        
        poleZeroCanvas.addEventListener('mouseup', () => {
            draggedElement = null;
            updateCustomFunction();
        });
        
        // 更新自定义函数显示
        function updateCustomFunction() {
            let functionStr = 'H(s) = ';
            
            // 分子部分
            if (zeros.length === 0) {
                functionStr += '1';
            } else if (zeros.length === 1) {
                const zero = zeros[0];
                if (zero.im === 0) {
                    functionStr += `(s ${zero.re >= 0 ? '-' : '+'} ${Math.abs(zero.re)})`;
                } else {
                    functionStr += `(s ${zero.re >= 0 ? '-' : '+'} ${Math.abs(zero.re)} ${zero.im >= 0 ? '-' : '+'} ${Math.abs(zero.im)}j)`;
                }
            } else {
                functionStr += '∏(s - z_i)';
            }
            
            // 分母部分
            if (poles.length === 0) {
                functionStr += ' / 1';
            } else if (poles.length === 1) {
                const pole = poles[0];
                functionStr += ' / (s';
                if (pole.re !== 0 || pole.im !== 0) {
                    if (pole.im === 0) {
                        functionStr += ` ${pole.re >= 0 ? '-' : '+'} ${Math.abs(pole.re)})`;
                    } else {
                        functionStr += ` ${pole.re >= 0 ? '-' : '+'} ${Math.abs(pole.re)} ${pole.im >= 0 ? '-' : '+'} ${Math.abs(pole.im)}j)`;
                    }
                } else {
                    functionStr += ')';
                }
            } else {
                functionStr += ' / ∏(s - p_i)';
            }
            
            updateFunctionDisplay(functionStr);
        }
        
        // 初始化
        drawPolesAndZeros();
        drawFrequencyResponse();
    </script>
</body>
</html>